// ... (остальной код)

// --- ФУНКЦИИ МОДАЛЬНОГО ОКНА (BOTTOM SHEET) ---

function openModal(id) {
    currentId = id; const p = db.find(x => x.id === id);
    document.getElementById('m-slider').innerHTML = p.images.map(url => `<div class="modal-slide"><img src="${url}"></div>`).join('');
    document.getElementById('m-title').innerText = p.name; 
    document.getElementById('m-price').innerText = p.price + ' ₽'; 
    document.getElementById('m-desc').innerText = p.desc;
    updateModalFavBtn(); 
    document.getElementById('modal').classList.add('modal-active');
    
    const scrollContent = document.querySelector('.modal-scroll-content');
    if (scrollContent) scrollContent.scrollTop = 0;
    
    // АКТИВИРУЕМ ЛОГИКУ БЛОКИРОВКИ СВАЙПА ПРИ ОТКРЫТИИ
    initIOSSwipeFix(); 
}

function closeModal(e) { 
    if (e) e.stopPropagation();
    document.getElementById('modal').classList.remove('modal-active'); 
}

function addCurrentToCart() { addOne(currentId); closeModal(); }


// --- КЛЮЧЕВОЙ ФИКС СВОРАЧИВАНИЯ НА IOS ---

let touchStartY = 0;
let isScrollingContent = false;
const scrollContainer = document.querySelector('.modal-scroll-content');

// Инициализация обработчиков
function initIOSSwipeFix() {
    if (!scrollContainer) return;

    // Сброс и добавление обработчиков при открытии шторки
    scrollContainer.removeEventListener('touchstart', onTouchStart);
    scrollContainer.removeEventListener('touchmove', onTouchMove);
    
    scrollContainer.addEventListener('touchstart', onTouchStart, { passive: false });
    scrollContainer.addEventListener('touchmove', onTouchMove, { passive: false });
}

function onTouchStart(e) {
    touchStartY = e.touches[0].clientY;
    // Определяем, что пользователь начал свайп внутри скроллящегося контента
    isScrollingContent = true; 
}

function onTouchMove(e) {
    if (!isScrollingContent) return;

    const currentY = e.touches[0].clientY;
    const scrollDelta = currentY - touchStartY;
    const scrollTop = scrollContainer.scrollTop;
    const scrollHeight = scrollContainer.scrollHeight;
    const containerHeight = scrollContainer.clientHeight;

    // 1. Прокрутка вверх (отталкивание от нижней границы):
    // Пользователь свайпает ВВЕРХ (scrollDelta < 0) И находится в самом низу скролла
    if (scrollDelta < 0 && (scrollTop + containerHeight >= scrollHeight - 1)) {
        // Запрещаем дальнейший скролл вверх в элементе
        // Но при этом блокируем прокрутку родителя, чтобы Telegram не пытался "перелистнуть" приложение
        e.preventDefault(); 
        return; 
    }

    // 2. Прокрутка вниз (отталкивание от верхней границы) - ЭТО НАША ПРОБЛЕМА:
    // Пользователь свайпает ВНИЗ (scrollDelta > 0) И находится в самом верху скролла
    if (scrollDelta > 0 && scrollTop === 0) {
        // !!! КЛЮЧЕВОЙ МОМЕНТ: БЛОКИРУЕМ НАТИВНОЕ ДЕЙСТВИЕ !!!
        e.preventDefault(); 
        return;
    }

    // Если скролл идет посередине, не блокируем
    // Reset startY for next move calculation
    touchStartY = currentY;
}
